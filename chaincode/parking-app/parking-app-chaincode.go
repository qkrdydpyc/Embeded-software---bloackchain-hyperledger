// SPDX-License-Identifier: Apache-2.0

/*
  Sample Chaincode based on Demonstrated Scenario

 This code is based on code written by the Hyperledger Fabric community.
  Original code can be found here: https://github.com/hyperledger/fabric-samples/blob/release/chaincode/fabcar/fabcar.go
*/

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"math"
	"strconv"
	"time"

	"github.com/digitorus/timestamp"
	"github.com/shopspring/decimal"

	. "github.com/parking/model"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	sc "github.com/hyperledger/fabric/protos/peer"

	"github.com/parking/parkingservice"
)

// Define the Smart Contract structure
type SmartContract struct {
	ParkingspotService   parkingservice.ParkingspotService
	ParkingTimeService   parkingservice.ParkingTimeService
	UserService          parkingservice.UserService
	ParkingCommonService parkingservice.ParkingCommonService //TESTING
	GeoHashService       parkingservice.GeoHashService
}

/*
 * The Init method *
 called when the Smart Contract "tuna-chaincode" is instantiated by the network
 * Best practice is to have any Ledger initialization in separate function
 -- see initLedger()
*/
func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) sc.Response {
	return shim.Success(nil)
}

/*
 * The Invoke method *
 called when an application requests to run the Smart Contract "tuna-chaincode"
 The app also specifies the specific smart contract function to call with args
*/
func (s *SmartContract) Invoke(APIstub shim.ChaincodeStubInterface) sc.Response {

	// Retrieve the requested Smart Contract function and arguments
	function, args := APIstub.GetFunctionAndParameters()
	// Route to the appropriate handler function to interact with the ledger
	if function == "getParkingTime" {
		return s.getParkingTimeC(APIstub, args)
	} else if function == "getParkingTimeC" {
		return s.getParkingTimeC(APIstub, args)
	} else if function == "getParkingTimeK" {
		return s.getParkingTime(APIstub, args)
	} else if function == "save" { //GENERIC save for debugging
		return s.saveCD(APIstub, args)
	} else if function == "saveC" { //GENERIC save for debugging
		return s.saveC(APIstub, args)
	} else if function == "saveCD" { //GENERIC save for debugging
		return s.saveCD(APIstub, args)
	} else if function == "getAll" {
		return s.getAll(APIstub)
		
	} else if function == "saveParkingtimeOpenTime" {
		return s.saveParkingtimeOpenTime(APIstub, args)
	} else if function == "saveReservation" {
		return s.saveReservation(APIstub, args)
	} else if function == "saveParkingtime" {
		return s.saveParkingtime(APIstub, args)
	} else if function == "getParkingtimesForParkingspot" {
		return s.getParkingtimesForParkingspot(APIstub, args)

	} else if function == "findBetweenTime" {
		return s.findBetweenTime(APIstub, args)
	} else if function == "extendParkingTime" {
		return s.extendParkingTime(APIstub, args)
	} else if function == "iextendParkingTime" {
		return s.iextendParkingTime(APIstub, args)
	} else if function == "EndParking" {
		return s.EndParking(APIstub, args)
		//user
	} else if function == "GetUsers" {
		return s.GetUsers(APIstub, args)
	} else if function == "GetUser" {
		return s.GetUser(APIstub, args)
	} else if function == "SetUser" {
		return s.SetUser(APIstub, args)

	} else if function == "findByQuery" {
		return s.findByQuery(APIstub, args)
	
	//parkingspots
	} else if function == "GetParkingspot" {
		return s.GetParkingspot(APIstub, args)
	} else if function == "GetOwnerParkingspots" {
		return s.GetOwnerParkingspots(APIstub, args)
	} else if function == "FindParkingspotToRent" {
		return s.FindParkingspotToRent(APIstub, args)
	} else if function == "SaveParkingspot" {
		return s.SaveParkingspot(APIstub, args)
		// return s.ForwardRequestToService(s.SaveParkingspot, APIstub, args)

	} else if function == "initLedger" {
		return s.initLedger(APIstub)
	}

	return shim.Error(fmt.Sprintf("Invalid Smart Contract function name: %s", function))
}

/**
 * Used to forward request to specific apiService
 */
func (s *SmartContract) ForwardRequestToService(fp func(shim.ChaincodeStubInterface, []string) sc.Response, APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	return fp(APIstub, args)
}

/*
 * The getParkingTime method *
Used to view the records of one particular tuna
It takes one argument -- the key for the tuna in question
*/
func (s *SmartContract) getParkingTime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	fmt.Printf("- SVENZIK getParkingTime:%s\n", args[0])
	resultAsBytes, _ := APIstub.GetState(args[0])
	if resultAsBytes == nil {
		return shim.Error("Could not locate tuna")
	}
	return shim.Success(resultAsBytes)
}

func (s *SmartContract) getParkingTimeC(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	parkingTimeId := args[0]
	fmt.Printf("- SVENZIK getParkingTime:%s\n", parkingTimeId)

	objectKeys := []string{parkingTimeId}
	compositeKey, _ := s.ParkingCommonService.CreateKey(APIstub, ParkingTime{}, objectKeys)
	fmt.Printf("Getting using key: %s\n", compositeKey)

	// parkingTime, _ := s.ParkingTimeService.Get(APIstub, parkingTimeId)
	// parkingTime, _ := s.ParkingTimeService.GetWithKeys(APIstub, objectKeys)
	// parkingTime, _ := s.ParkingCommonService.GetObject(APIstub, objectKeys, ParkingTime{})

	// resultAsBytes, _ := json.Marshal(parkingTime)
	// if resultAsBytes == nil {
	// 	return shim.Error("Could not marshal PT")
	// }
	//FIXME: all should work correctly
	resultAsBytes := []byte("")
	resultAsBytesService := []byte("")

	// resultAsBytesService, err = APIstub.GetState(compositeKey)
	// // resultAsBytes = append(resultAsBytes, []byte("\nNOSERVICE: ")...)
	// resultAsBytes = append(resultAsBytes, resultAsBytesService...)

	parkingTime, _ := s.ParkingCommonService.GetObject(APIstub, objectKeys, ParkingTime{})
	resultAsBytesService, _ = json.Marshal(parkingTime)
	// resultAsBytes = append(resultAsBytes, []byte("\nCSERVICE: ")...)
	resultAsBytes = append(resultAsBytes, resultAsBytesService...)

	// parkingTime, _ = s.ParkingTimeService.GetWithKeys(APIstub, objectKeys)
	// resultAsBytesService, _ = json.Marshal(parkingTime)
	// resultAsBytes = append(resultAsBytes, []byte("\nKSERVICE: ")...)
	// resultAsBytes = append(resultAsBytes, resultAsBytesService...)
	//
	// parkingTime, _ =s.ParkingTimeService.Get(APIstub, parkingTimeId)
	// resultAsBytesService, _ = json.Marshal(parkingTime)
	// resultAsBytes = append(resultAsBytes, []byte("\nOSERVICE: ")...)
	// resultAsBytes = append(resultAsBytes, resultAsBytesService...)

	return shim.Success(resultAsBytes)
}

/*
 * The findByQuery method *
Used to search the records of one particular tuna
It takes one argument -- the coudhDB query string for the tuna in question
*/
func (s *SmartContract) findByQuery(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	queryString := args[0]
	fmt.Printf("- queryString:\n%s\n", queryString)

	resultsIterator, err := APIstub.GetQueryResult(queryString)
	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	result, err := s.marshalQueryResult(resultsIterator)
	fmt.Printf("- findByQuery:\n%s\n", result)

	return shim.Success([]byte(result))
}

func (s *SmartContract) getParkingtimesForParkingspot(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	ParkingspotId := args[0]
	queryString := fmt.Sprintf("{\"selector\": {\"parkingspot.id\": {\"$eq\": \"%s\"}}}", ParkingspotId)
	resultsIterator, err := APIstub.GetQueryResult(queryString)
	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	result, err := s.marshalQueryResult(resultsIterator)
	return shim.Success([]byte(result))
}

func (s *SmartContract) findBetweenTime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	resultsIterator, err := s.findParkingspotOverlapingIsoString(APIstub, args[0], args[1])
	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	result, err := s.marshalQueryResult(resultsIterator)
	fmt.Printf("- findBetweenTime:\n%s\n", result)

	return shim.Success([]byte(result))
}

/*
 * The initLedger method
 */
func (s *SmartContract) initLedger(APIstub shim.ChaincodeStubInterface) sc.Response {
	s.UserService.Save(APIstub, User{
		Id: "1",
		Name: "Prisma",
		Balance: Balance{CurrencyName: "EUR", Amount: decimal.NewFromFloat(100.0)},
	})
	s.UserService.Save(APIstub, User{
		Id: "2",
		Name: "Rimi",
		Balance: Balance{CurrencyName: "EUR", Amount: decimal.NewFromFloat(200.0)},
	})
	s.UserService.Save(APIstub, User{
		Id: "3",
		Name: "UT",
		Balance: Balance{CurrencyName: "EUR", Amount: decimal.NewFromFloat(300.0)},
	})

	psSelver := Parkingspot{
		Id: "1",
		Name: "Tartu-Sobra-tee-1-315",
		CostPerMinute: CurrencyAmount{CurrencyName: "EUR", Amount: decimal.NewFromFloat(10.0)},
		Owner: User{
			Id: "1",
			Name: "Prisma",
		},
		Location: s.GeoHashService.CreateLocation(58.364254, 26.741460),
	}
	psRimi := Parkingspot{
		Id: "2",
		Name: "Tartu-Sobra-tee-2-1",
		CostPerMinute: CurrencyAmount{CurrencyName: "EUR", Amount: decimal.NewFromFloat(13.0)},
		Owner: User{
			Id: "2",
			Name: "Rimi",
		},
		Location: s.GeoHashService.CreateLocation(58.368405, 26.738235),
	}
	psUT1 := Parkingspot{
		Id: "3",
		Name: "Liivi 2-1",
		CostPerMinute: CurrencyAmount{CurrencyName: "EUR", Amount: decimal.NewFromFloat(9.0)},
		Owner: User{
			Id: "3",
			Name: "UT",
		},
		Location: s.GeoHashService.CreateLocation(58.3785427, 26.7143264),
	}
	psUT2 := Parkingspot{
		Id: "4",
		Name: "Liivi 2-2",
		CostPerMinute: CurrencyAmount{CurrencyName: "EUR", Amount: decimal.NewFromFloat(9.0)},
		Owner: User{
			Id: "3",
			Name: "UT",
		},
		Location: s.GeoHashService.CreateLocation(58.378538, 26.714325),
	}

	s.ParkingspotService.Save(APIstub, psSelver)
	s.ParkingspotService.Save(APIstub, psRimi)
	s.ParkingspotService.Save(APIstub, psUT1)
	s.ParkingspotService.Save(APIstub, psUT2)

	s.ParkingTimeService.SaveParkingtimeOpenTime(APIstub,  ParkingTime{
		Id: "1",
		ParkingStart: time.Now(),
		ParkingEnd: time.Now().Add(8 * time.Hour),
		CostPerMinute: 10,
		Parkingspot: psSelver})
	s.ParkingTimeService.SaveParkingtimeOpenTime(APIstub, ParkingTime{
		Id: "2",
		ParkingStart: time.Now(),
		ParkingEnd: time.Now().Add(8 * time.Hour),
		CostPerMinute: 12,
		Parkingspot: psRimi})
	s.ParkingTimeService.SaveParkingtimeOpenTime(APIstub, ParkingTime{
		Id: "3",
		ParkingStart: time.Now(),
		ParkingEnd: time.Now().Add(8 * time.Hour),
		CostPerMinute: 3,
		Parkingspot: psUT1})
	s.ParkingTimeService.SaveParkingtimeOpenTime(APIstub, ParkingTime{
		Id: "4",
		ParkingStart: time.Now(),
		ParkingEnd: time.Now().Add(8 * time.Hour),
		CostPerMinute: 3,
		Parkingspot: psUT2})

	parkingSpot := []ParkingTime{
		ParkingTime{ParkingStart: time.Now(), ParkingEnd: time.Now(), CostPerMinute: 10, Parkingspot: psUT1},
		ParkingTime{ParkingStart: time.Now().Add(2 * time.Minute), ParkingEnd: time.Now().Add(5 * time.Minute), CostPerMinute: 10, Parkingspot: psUT1},
		ParkingTime{ParkingStart: time.Now().Add(10 * time.Minute), ParkingEnd: time.Now().Add(30 * time.Minute), CostPerMinute: 10, Parkingspot: psUT1},
		ParkingTime{ParkingStart: time.Now().Add(31 * time.Minute), ParkingEnd: time.Now().Add(45 * time.Minute), CostPerMinute: 10, Parkingspot: psUT1},
		ParkingTime{ParkingStart: time.Now().Add(25 * time.Minute), ParkingEnd: time.Now().Add(45 * time.Minute), CostPerMinute: 10, Parkingspot: psUT2},
		ParkingTime{ParkingStart: time.Now().Add(46 * time.Minute), ParkingEnd: time.Now().Add(105 * time.Minute), CostPerMinute: 10, Parkingspot: psUT2},
	}

	i := 10
	for i < len(parkingSpot) {
		ps := parkingSpot[i]
		ps.Id = strconv.Itoa(i + 1)
		s.ParkingTimeService.SaveParkingtime(APIstub, ps)
		fmt.Println("Added", parkingSpot[i])
		i = i + 1
	}

	return shim.Success(nil)
}

/*
 * The save method *
Fisherman like Sarah would use to record each of her parkingSpot catches.
This method takes in five arguments (attributes to be saved in the ledger).
*/
func (s *SmartContract) save(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	// parkingTime := ParkingTime{}
	// json.Unmarshal([]byte(args[1]), &parkingTime)
	parkingTime, err := s.unmarshal(args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parkingTime: %s", err))
	}

	result, err := s.put(APIstub, args[0], parkingTime)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to persist reservation: %s", err))
	}
	return shim.Success(result)
	// resultAsBytes, _ := json.Marshal(parkingTime)
	// err = APIstub.PutState(args[0], resultAsBytes)
	// if err != nil {
	// 	return shim.Error(fmt.Sprintf("Failed to record parkingTime: %s", args[0]))
	// }
	//
	// return shim.Success(resultAsBytes)
}

func (s *SmartContract) saveC(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	parkingTime, err := s.unmarshal(args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parkingTime: %s", err))
	}

	parkingTime.Id = args[0]
	ptResult, err := s.ParkingTimeService.Save(APIstub, parkingTime)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to persist parkingTime: %s", err))
	}

	objectKeys := []string{parkingTime.Id}
	keyString, _ := s.ParkingCommonService.CreateKey(APIstub, parkingTime, objectKeys)
	ptResult.Id = keyString + " from: " + parkingTime.Id

	result, _ := json.Marshal(ptResult)
	return shim.Success(result)
}

func (s *SmartContract) saveCD(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	parkingTime, err := s.unmarshal(args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parkingTime: %s", err))
	}

	parkingTime.Id = args[0]

	objectKeys := []string{parkingTime.Id}
	compositeKey, _ := s.ParkingCommonService.CreateKey(APIstub, parkingTime, objectKeys)
	fmt.Printf("Saving using key: %s", compositeKey)

	resultAsBytes, err := json.Marshal(parkingTime)
	err = APIstub.PutState(compositeKey, resultAsBytes)

	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to persist parkingTime: %s", err))
	}

	resultAsBytes, err = APIstub.GetState(compositeKey)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to get parkingTime: %s", err))
	}

	return shim.Success(resultAsBytes)
}

func (s *SmartContract) saveParkingtimeOpenTime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	parkingTime, err := s.unmarshal(args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parkingTime free. %s: %s", err, args[1]))
	}

	parkingTimeResult, err := s.ParkingTimeService.SaveParkingtimeOpenTime(APIstub, parkingTime)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to persist parkingTime: %s", err))
	}
	
	result, _ := json.Marshal(parkingTimeResult)
	return shim.Success(result)
}

func (s *SmartContract) saveReservation(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	parkingTime, err := s.unmarshal(args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parkingTime reservation. %s: %s", err, args[1]))
	}

	fmt.Printf("Saving reservation: %s\n",  args[1])

	resultsIterator, err := s.findParkingspotOverlaping(APIstub, parkingTime.ParkingStart, parkingTime.ParkingEnd)
	if err != nil {
		return shim.Error(fmt.Sprintf("Error: saveReservation findParkingspotOverlaping: %s\n%s\n", err, args[1]))		
	}
	if resultsIterator.HasNext() {
		queryResponse, _ := resultsIterator.Next()
		fmt.Printf("saveReservation: Found second parkingtime: %s\n",  queryResponse.Value)
		existingParkingTime := ParkingTime{}
		err := json.Unmarshal(queryResponse.Value, &existingParkingTime)
		if err != nil {
			return shim.Error(fmt.Sprintf("Error unmarshal: %s -> %s", err, queryResponse.Value))
		}
		if existingParkingTime.ParkingType != "FREE" && existingParkingTime.Parkingspot.Id == parkingTime.Parkingspot.Id {
			return shim.Error(fmt.Sprintf("Time is overlaping with : %s", existingParkingTime))
		}
	}

	parkingTimeResult, err := s.ParkingTimeService.SaveParkingtimeReservation(APIstub, parkingTime)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to persist parkingTime: %s", err))
	}
	
	result, _ := json.Marshal(parkingTimeResult)
	return shim.Success(result)
}

func (s *SmartContract) saveParkingtime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	parkingTime, err := s.unmarshal(args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parkingTime. %s: %s", err, args[1]))
	}

	resultsIterator, _ := s.findParkingspotOverlaping(APIstub, parkingTime.ParkingStart, parkingTime.ParkingEnd)
	if resultsIterator.HasNext() {
		queryResponse, _ := resultsIterator.Next()
		existingParkingTime := ParkingTime{}
		err := json.Unmarshal(queryResponse.Value, &existingParkingTime)
		fmt.Printf("Found matcing parkingtime: %s\n",  existingParkingTime);
		if err != nil {
			return shim.Error(fmt.Sprintf("Error unmarshal: %s -> %s", err, queryResponse.Value))
		}
		if existingParkingTime.ParkingType != "FREE" && existingParkingTime.Parkingspot.Id == parkingTime.Parkingspot.Id {
			return shim.Error(fmt.Sprintf("Time is overlaping with : %s", existingParkingTime))
		}
	}

	parkingTimeResult, err := s.ParkingTimeService.SaveParkingtime(APIstub, parkingTime)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to persist parkingTime: %s", err))
	}
	
	result, _ := json.Marshal(parkingTimeResult)
	return shim.Success(result)
}

/*
 * The getAll method *
allows for assessing all the records added to the ledger(all tuna catches)
This method does not take any arguments. Returns JSON string containing results.
*/
func (s *SmartContract) getAll(APIstub shim.ChaincodeStubInterface) sc.Response {

	startKey := "0"
	endKey := "999"
	resultsIterator, err := APIstub.GetStateByRange(startKey, endKey)

	// startKey,_ :=  APIstub.CreateCompositeKey("ParkingTime", []string{"1"})
	// endKey,_ := APIstub.CreateCompositeKey("ParkingTime",  []string{"999"})
	// resultsIterator, err := APIstub.GetStateByPartialCompositeKey("ParkingTime", []string{"1"})

	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	// buffer is a JSON array containing QueryResults
	var buffer bytes.Buffer
	buffer.WriteString("[")

	bArrayMemberAlreadyWritten := false
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return shim.Error(err.Error())
		}
		// Add comma before array members,suppress it for the first array member
		if bArrayMemberAlreadyWritten == true {
			buffer.WriteString(",")
		}
		buffer.WriteString("{\"Key\":")
		buffer.WriteString("\"")
		buffer.WriteString(queryResponse.Key)
		buffer.WriteString("\"")

		buffer.WriteString(", \"Record\":")
		// Record is a JSON object, so we write as-is
		buffer.WriteString(string(queryResponse.Value))
		buffer.WriteString("}")
		bArrayMemberAlreadyWritten = true
	}
	buffer.WriteString("]")

	fmt.Printf("- getAll:\n%s\n", buffer.String())

	return shim.Success(buffer.Bytes())
}

/*
 * The extendParkingTime method *
The data in the world state can be updated with who has possession.
This function takes in 2 arguments, tuna id and new holder name.
*/
func (s *SmartContract) extendParkingTime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	//TODO: check if it conflicts with some other parkingTime
	resultAsBytes, _ := APIstub.GetState(args[0])
	if resultAsBytes == nil {
		return shim.Error("Could not locate ParkingTime")
	}
	parkingTime := ParkingTime{}
	json.Unmarshal(resultAsBytes, &parkingTime)
	// Normally check that the specified argument is a valid holder of parkingTime
	// we are skipping this check for this example
	endTime, err := time.Parse(time.RFC3339, args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to parse new end parkingTime: %s", args[1]))
	}
	parkingTime.ParkingEnd = endTime

	resultAsBytes, _ = json.Marshal(parkingTime)
	err = APIstub.PutState(args[0], resultAsBytes)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to change parkingTime: %s", args[0]))
	}

	return shim.Success(resultAsBytes)
}

/*
 * The extendParkingTime method *
The data in the world state can be updated with who has possession.
This function takes in 2 arguments, tuna id and new holder name.
*/
func (s *SmartContract) iextendParkingTime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	//TODO: check if it conflicts with some other parkingTime
	resultAsBytes, _ := APIstub.GetState(args[0])
	if resultAsBytes == nil {
		return shim.Error("Could not locate ParkingTime")
	}
	parkingTime := ParkingTime{}
	json.Unmarshal(resultAsBytes, &parkingTime)
	// Normally check that the specified argument is a valid holder of parkingTime
	// we are skipping this check for this example
	parkingTime.ParkingStart = parkingTime.ParkingEnd
	endTime, err := time.Parse(time.RFC3339, args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to parse new end parkingTime: %s", args[1]))
	}
	parkingTime.ParkingEnd = endTime
	//TODO: fix new id generation
	newId, errAtoi := strconv.Atoi(args[0])
	newId = newId + 1
	if errAtoi != nil {
		newId = -1
	}
	resultAsBytes, _ = json.Marshal(parkingTime)
	err = APIstub.PutState(strconv.Itoa(newId), resultAsBytes)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to change parkingTime: %s", args[0]))
	}

	return shim.Success(resultAsBytes)
}

/*
 * The EndParking method *
The data in the world state can be updated with who has possession.
This function takes in 2 arguments, tuna id and new holder name.
*/
func (s *SmartContract) EndParking(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1, id of parkingTime")
	}

	parkingTimeId := args[0]
	fmt.Printf("Ending parking for id: %s\n", parkingTimeId)
	//1
	// parkingTime, err := s.ParkingTimeService.Get(APIstub, parkingTimeId)

	//2
	// objectKeys :=  []string{parkingTimeId}
	// parkingTimeObject, err := s.ParkingCommonService.GetObject(APIstub, objectKeys, ParkingTime{})
	// fmt.Printf("Got parking: %s\n", parkingTimeObject)
	// parkingTime, _ := parkingTimeObject.(ParkingTime)

	//3
	objectKeys := []string{parkingTimeId}
	compositeKey, _ := s.ParkingCommonService.CreateKey(APIstub, ParkingTime{}, objectKeys)
	oResultAsBytes, err := APIstub.GetState(compositeKey)
	parkingTime := ParkingTime{}
	err = json.Unmarshal(oResultAsBytes, &parkingTime)

	fmt.Printf("Got parking type: %s\n", parkingTime)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to find parkingTime(%s): %s", parkingTimeId, err))
	}

	//TIME CALCULATIONS
	calculatedEndTime := CurrentTimestamp{TimeWindow: time.Minute * 5, Errors: []string{}}
	ts, _ := APIstub.GetTxTimestamp()

	//using current timestamp of server - will not work in multipeer envir
	// calculatedEndTime = time.Now()

	//Using transaction timestamp set by client, unsafe
	calculatedEndTime.TransactionTime = time.Unix(ts.Seconds, int64(ts.Nanos)).UTC()

	//Using transaction timestamp set by client with chekcing window (lets say 5min)
	endorsedEndTime := time.Unix(ts.Seconds, int64(ts.Nanos)).UTC()
	if math.Abs(time.Now().Sub(endorsedEndTime).Minutes()) < calculatedEndTime.TimeWindow.Minutes() {
		calculatedEndTime.TimeWindowCurrentTime = time.Unix(ts.Seconds, int64(ts.Nanos)).UTC()
	}

	// USING Timestamp Protocol
	// Time-Stamp request with nonce, to create with OpenSSL:
	//   $ openssl ts -query -data data.txt -cert -sha256 -out reqnonoce.tsq
	tspResponse := []byte{0x30, 0x82, 0xe, 0x35, 0x30, 0x3, 0x2, 0x1, 0x0, 0x30, 0x82, 0xe, 0x2c, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x7, 0x2, 0xa0, 0x82, 0xe, 0x1d, 0x30, 0x82, 0xe, 0x19, 0x2, 0x1, 0x3, 0x31, 0xf, 0x30, 0xd, 0x6, 0x9, 0x60, 0x86, 0x48, 0x1, 0x65, 0x3, 0x4, 0x2, 0x1, 0x5, 0x0, 0x30, 0x81, 0xed, 0x6, 0xb, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x9, 0x10, 0x1, 0x4, 0xa0, 0x81, 0xdd, 0x4, 0x81, 0xda, 0x30, 0x81, 0xd7, 0x2, 0x1, 0x1, 0x6, 0x9, 0x2b, 0x6, 0x1, 0x4, 0x1, 0xa0, 0x32, 0x2, 0x1, 0x30, 0x31, 0x30, 0xd, 0x6, 0x9, 0x60, 0x86, 0x48, 0x1, 0x65, 0x3, 0x4, 0x2, 0x1, 0x5, 0x0, 0x4, 0x20, 0xf4, 0x87, 0xd8, 0x81, 0x64, 0xbd, 0xe2, 0x23, 0xb7, 0xfd, 0x3c, 0x71, 0xb3, 0xe9, 0xc6, 0x24, 0xc8, 0xa0, 0xcb, 0x55, 0x9c, 0x85, 0x3b, 0x49, 0x55, 0x8e, 0x7e, 0x5e, 0xf4, 0xce, 0x55, 0xf0, 0x2, 0x14, 0x5, 0xee, 0xb0, 0xc5, 0x78, 0x43, 0x5b, 0xa7, 0x17, 0x90, 0x39, 0x4f, 0xeb, 0xb8, 0x21, 0x67, 0xb3, 0x64, 0x4c, 0xcc, 0x18, 0xf, 0x32, 0x30, 0x31, 0x37, 0x30, 0x34, 0x31, 0x39, 0x30, 0x36, 0x32, 0x39, 0x35, 0x33, 0x5a, 0x30, 0x3, 0x2, 0x1, 0x1, 0x2, 0x8, 0x9, 0x2e, 0xf1, 0x9f, 0xfb, 0x5d, 0x2a, 0xe8, 0xa0, 0x5e, 0xa4, 0x5c, 0x30, 0x5a, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x53, 0x47, 0x31, 0x1f, 0x30, 0x1d, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0x16, 0x47, 0x4d, 0x4f, 0x20, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x50, 0x74, 0x65, 0x20, 0x4c, 0x74, 0x64, 0x31, 0x2a, 0x30, 0x28, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x21, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x54, 0x53, 0x41, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x20, 0x43, 0x44, 0x53, 0x20, 0x2d, 0x20, 0x47, 0x32, 0xa0, 0x82, 0xa, 0x47, 0x30, 0x82, 0x5, 0x47, 0x30, 0x82, 0x4, 0x2f, 0xa0, 0x3, 0x2, 0x1, 0x2, 0x2, 0x12, 0x11, 0x21, 0xd2, 0xd1, 0x82, 0xa, 0xf0, 0xa5, 0xc5, 0x48, 0x14, 0x9a, 0x32, 0x74, 0xdc, 0xc3, 0x43, 0x57, 0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0xb, 0x5, 0x0, 0x30, 0x72, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d, 0x73, 0x61, 0x31, 0x17, 0x30, 0x15, 0x6, 0x3, 0x55, 0x4, 0xb, 0x13, 0xe, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x43, 0x44, 0x53, 0x31, 0x2f, 0x30, 0x2d, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x26, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x20, 0x43, 0x41, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x30, 0x1e, 0x17, 0xd, 0x31, 0x36, 0x30, 0x35, 0x32, 0x34, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x17, 0xd, 0x32, 0x32, 0x30, 0x35, 0x32, 0x34, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x30, 0x5a, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x53, 0x47, 0x31, 0x1f, 0x30, 0x1d, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0x16, 0x47, 0x4d, 0x4f, 0x20, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x50, 0x74, 0x65, 0x20, 0x4c, 0x74, 0x64, 0x31, 0x2a, 0x30, 0x28, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x21, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x54, 0x53, 0x41, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x20, 0x43, 0x44, 0x53, 0x20, 0x2d, 0x20, 0x47, 0x32, 0x30, 0x82, 0x1, 0x22, 0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0x1, 0x5, 0x0, 0x3, 0x82, 0x1, 0xf, 0x0, 0x30, 0x82, 0x1, 0xa, 0x2, 0x82, 0x1, 0x1, 0x0, 0xd7, 0xbc, 0xf9, 0x4f, 0xea, 0xab, 0x40, 0xdf, 0x15, 0x5c, 0xd4, 0xe8, 0xa5, 0x8e, 0x7a, 0x8, 0x2e, 0xc6, 0x15, 0xea, 0xa, 0xc, 0x69, 0x94, 0xae, 0x9, 0xc2, 0xe2, 0x86, 0xc, 0xf4, 0xed, 0x18, 0x60, 0x5b, 0x9f, 0x28, 0x9b, 0x6c, 0xdb, 0xf3, 0xa7, 0x55, 0x2b, 0xd7, 0x5, 0x5e, 0x81, 0xd0, 0xed, 0xe6, 0xf4, 0xe2, 0xb8, 0x28, 0x12, 0x46, 0xa7, 0x27, 0xfd, 0x8a, 0x89, 0x65, 0x5e, 0x1a, 0x4b, 0x58, 0x67, 0xbc, 0x10, 0xa9, 0x2b, 0x4c, 0x5e, 0xb0, 0x85, 0xdf, 0x7f, 0x59, 0x6c, 0x9e, 0x8c, 0xe1, 0xb9, 0x5f, 0x8f, 0x70, 0x4f, 0xf9, 0x58, 0x0, 0x70, 0x78, 0x2a, 0xcb, 0xd5, 0x36, 0x15, 0xb1, 0xe8, 0xc0, 0x62, 0xa5, 0x7a, 0xe2, 0x6b, 0xa7, 0x90, 0xa5, 0x1, 0x95, 0x6c, 0xa6, 0x8c, 0xea, 0x2a, 0x8a, 0xe5, 0x2a, 0x3e, 0xd3, 0x42, 0xbc, 0x8e, 0x5a, 0xb1, 0x18, 0x18, 0x71, 0x4c, 0x84, 0x7c, 0xaf, 0xf5, 0xb, 0x49, 0x1c, 0x16, 0xf6, 0x50, 0xf9, 0xaf, 0xb0, 0x20, 0x4f, 0x40, 0x49, 0x35, 0xe5, 0x5, 0x9b, 0xaf, 0x6, 0x6f, 0xca, 0x89, 0xb8, 0xe8, 0xae, 0x92, 0x18, 0xb1, 0xb2, 0x56, 0xf1, 0xad, 0x70, 0x94, 0x96, 0x47, 0xea, 0xeb, 0x4f, 0x26, 0x1, 0x5a, 0xd2, 0x65, 0xeb, 0x25, 0xd0, 0x19, 0xb, 0x22, 0x3c, 0xb0, 0x2e, 0x7b, 0x88, 0x92, 0x9, 0x1a, 0xb3, 0xf9, 0x80, 0xa2, 0x7e, 0x90, 0x78, 0xca, 0x4a, 0x20, 0x8b, 0xc4, 0xd, 0xe9, 0x5f, 0x66, 0xb, 0x5c, 0xac, 0xb2, 0xc4, 0x9c, 0x1b, 0xf7, 0x95, 0x24, 0xdc, 0x13, 0x83, 0x8c, 0x94, 0xc8, 0x57, 0xd8, 0x4f, 0x33, 0xf2, 0xda, 0x5d, 0x73, 0x70, 0x4f, 0x3a, 0xc9, 0xa2, 0x5f, 0x2a, 0x7c, 0x71, 0xc9, 0xc1, 0x4a, 0x5d, 0xe1, 0x98, 0x34, 0x6b, 0xd3, 0xc1, 0x74, 0x15, 0x33, 0x89, 0x93, 0x2, 0x3, 0x1, 0x0, 0x1, 0xa3, 0x82, 0x1, 0xed, 0x30, 0x82, 0x1, 0xe9, 0x30, 0xe, 0x6, 0x3, 0x55, 0x1d, 0xf, 0x1, 0x1, 0xff, 0x4, 0x4, 0x3, 0x2, 0x7, 0x80, 0x30, 0x81, 0xdd, 0x6, 0x3, 0x55, 0x1d, 0x20, 0x4, 0x81, 0xd5, 0x30, 0x81, 0xd2, 0x30, 0x81, 0xcf, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x2f, 0x1, 0x2, 0x1, 0x30, 0x81, 0xc1, 0x30, 0x81, 0x8a, 0x6, 0x8, 0x2b, 0x6, 0x1, 0x5, 0x5, 0x7, 0x2, 0x2, 0x30, 0x7e, 0xc, 0x7c, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x69, 0x73, 0x73, 0x75, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x63, 0x63, 0x6f, 0x72, 0x64, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x43, 0x44, 0x53, 0x20, 0x43, 0x50, 0x53, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x6f, 0x72, 0x79, 0x2f, 0x30, 0x32, 0x6, 0x8, 0x2b, 0x6, 0x1, 0x5, 0x5, 0x7, 0x2, 0x1, 0x16, 0x26, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x6f, 0x72, 0x79, 0x2f, 0x30, 0x9, 0x6, 0x3, 0x55, 0x1d, 0x13, 0x4, 0x2, 0x30, 0x0, 0x30, 0x16, 0x6, 0x3, 0x55, 0x1d, 0x25, 0x1, 0x1, 0xff, 0x4, 0xc, 0x30, 0xa, 0x6, 0x8, 0x2b, 0x6, 0x1, 0x5, 0x5, 0x7, 0x3, 0x8, 0x30, 0x40, 0x6, 0x3, 0x55, 0x1d, 0x1f, 0x4, 0x39, 0x30, 0x37, 0x30, 0x35, 0xa0, 0x33, 0xa0, 0x31, 0x86, 0x2f, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x72, 0x6c, 0x2e, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x67, 0x73, 0x2f, 0x67, 0x73, 0x70, 0x72, 0x6d, 0x73, 0x68, 0x61, 0x32, 0x61, 0x64, 0x6f, 0x62, 0x65, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x52, 0x6, 0x8, 0x2b, 0x6, 0x1, 0x5, 0x5, 0x7, 0x1, 0x1, 0x4, 0x46, 0x30, 0x44, 0x30, 0x42, 0x6, 0x8, 0x2b, 0x6, 0x1, 0x5, 0x5, 0x7, 0x30, 0x2, 0x86, 0x36, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x2e, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74, 0x2f, 0x67, 0x73, 0x70, 0x72, 0x6d, 0x73, 0x68, 0x61, 0x32, 0x61, 0x64, 0x6f, 0x62, 0x65, 0x2e, 0x64, 0x65, 0x72, 0x30, 0x1d, 0x6, 0x3, 0x55, 0x1d, 0xe, 0x4, 0x16, 0x4, 0x14, 0x48, 0x78, 0xeb, 0x96, 0x27, 0x1e, 0x4e, 0xbd, 0xe4, 0x5b, 0x2a, 0x65, 0x11, 0xbb, 0x92, 0x1c, 0xc6, 0x1, 0x96, 0x38, 0x30, 0x1f, 0x6, 0x3, 0x55, 0x1d, 0x23, 0x4, 0x18, 0x30, 0x16, 0x80, 0x14, 0x59, 0xd8, 0x24, 0xc2, 0xcf, 0x6b, 0x6, 0x42, 0xd4, 0x95, 0x76, 0xb5, 0x29, 0x5c, 0xf5, 0xd8, 0x41, 0x2b, 0x24, 0x5f, 0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0xb, 0x5, 0x0, 0x3, 0x82, 0x1, 0x1, 0x0, 0x1b, 0xfa, 0xb9, 0xab, 0x45, 0xab, 0x43, 0x92, 0xf3, 0x67, 0xb2, 0x25, 0xb7, 0x20, 0x94, 0xb2, 0xee, 0x9a, 0xa5, 0xba, 0x78, 0xa4, 0x46, 0xbe, 0x8c, 0x9e, 0x9e, 0xfd, 0xb7, 0xb7, 0x5c, 0x28, 0x65, 0x13, 0xc7, 0x12, 0x38, 0xbf, 0xf6, 0x8c, 0xee, 0xba, 0x21, 0x62, 0x30, 0xa6, 0xbe, 0xfe, 0xb8, 0x16, 0x1f, 0x86, 0x0, 0x1e, 0xa2, 0x65, 0x2c, 0x80, 0xb, 0x15, 0xe2, 0x16, 0x72, 0x5, 0xad, 0x61, 0x9f, 0xd8, 0xca, 0x1d, 0x12, 0xa8, 0x41, 0x5a, 0xc5, 0x3b, 0x3, 0xb9, 0x65, 0xd4, 0xa3, 0x8, 0xcc, 0x4, 0xc0, 0xa8, 0x3, 0x35, 0xe1, 0xfe, 0xfd, 0x3a, 0x98, 0x13, 0x3d, 0x8d, 0xb5, 0x81, 0x7b, 0x36, 0x38, 0xc7, 0xc5, 0x7, 0x29, 0x6d, 0x4, 0x6b, 0x6e, 0x9a, 0xdf, 0x1c, 0x6c, 0x16, 0x73, 0xed, 0x52, 0xfd, 0xf6, 0x24, 0xdf, 0x1, 0x28, 0xae, 0x3, 0xc, 0x66, 0xc5, 0x54, 0x4d, 0xf8, 0x9f, 0xdb, 0x0, 0xa6, 0x94, 0xc4, 0xc7, 0x20, 0x36, 0x49, 0x35, 0x23, 0xbe, 0x1f, 0xbb, 0xa7, 0x17, 0x28, 0xba, 0x1a, 0x27, 0xdf, 0x5f, 0xf4, 0x8e, 0xac, 0x6b, 0xf4, 0x7, 0xa7, 0x8b, 0xf7, 0x1e, 0x90, 0xd7, 0xcc, 0xd, 0xf1, 0x48, 0xec, 0xd5, 0x23, 0xed, 0xcb, 0x5f, 0x11, 0xbe, 0x7, 0x64, 0x67, 0x40, 0x7e, 0xf1, 0x9c, 0x6f, 0xc0, 0xd6, 0xd2, 0xd6, 0x82, 0xb7, 0x39, 0xa1, 0xd3, 0xf7, 0x14, 0xf1, 0x38, 0xdb, 0x86, 0x0, 0xcb, 0x43, 0xdf, 0x3, 0x42, 0x9, 0xd7, 0xaf, 0xed, 0x6, 0xf1, 0xc6, 0x47, 0xe7, 0xbc, 0xae, 0x29, 0xdb, 0x43, 0x7, 0xe2, 0xf5, 0xd1, 0xb3, 0xb0, 0x47, 0xbb, 0x47, 0x6b, 0x3, 0x8f, 0x49, 0x6, 0xc6, 0x8b, 0x92, 0xf5, 0x56, 0x7b, 0xdc, 0xb8, 0x21, 0x5c, 0x52, 0x2, 0x51, 0x1c, 0x7b, 0x9, 0x58, 0x43, 0x59, 0xa9, 0x37, 0x30, 0x82, 0x4, 0xf8, 0x30, 0x82, 0x3, 0xe0, 0xa0, 0x3, 0x2, 0x1, 0x2, 0x2, 0x10, 0x35, 0xfb, 0xe4, 0xfa, 0xdf, 0xe4, 0xb0, 0x92, 0x27, 0x6c, 0x31, 0x9b, 0x99, 0xf8, 0xce, 0xb3, 0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0xb, 0x5, 0x0, 0x30, 0x69, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x55, 0x53, 0x31, 0x23, 0x30, 0x21, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0x1a, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x20, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x73, 0x20, 0x49, 0x6e, 0x63, 0x6f, 0x72, 0x70, 0x6f, 0x72, 0x61, 0x74, 0x65, 0x64, 0x31, 0x1d, 0x30, 0x1b, 0x6, 0x3, 0x55, 0x4, 0xb, 0x13, 0x14, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x31, 0x16, 0x30, 0x14, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0xd, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 0x41, 0x30, 0x1e, 0x17, 0xd, 0x31, 0x31, 0x30, 0x35, 0x32, 0x35, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x17, 0xd, 0x32, 0x32, 0x30, 0x35, 0x32, 0x34, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5a, 0x30, 0x72, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d, 0x73, 0x61, 0x31, 0x17, 0x30, 0x15, 0x6, 0x3, 0x55, 0x4, 0xb, 0x13, 0xe, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x43, 0x44, 0x53, 0x31, 0x2f, 0x30, 0x2d, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x26, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x20, 0x43, 0x41, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x30, 0x82, 0x1, 0x22, 0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0x1, 0x5, 0x0, 0x3, 0x82, 0x1, 0xf, 0x0, 0x30, 0x82, 0x1, 0xa, 0x2, 0x82, 0x1, 0x1, 0x0, 0xc2, 0xc6, 0xb, 0x84, 0x55, 0x5a, 0x96, 0x36, 0x1d, 0x95, 0xe7, 0x88, 0xed, 0xd0, 0x2d, 0x23, 0xb1, 0x2a, 0x37, 0xc4, 0xb, 0x35, 0x7f, 0xc7, 0x4, 0x69, 0x36, 0x90, 0x53, 0xd3, 0x56, 0x5a, 0x13, 0x8, 0x1f, 0xc0, 0xc6, 0x46, 0x38, 0x81, 0x72, 0x76, 0xa7, 0xff, 0x9e, 0x5d, 0xc5, 0x83, 0x52, 0x8a, 0x11, 0x7, 0x5a, 0x8b, 0xb5, 0xb3, 0x1f, 0x37, 0xf4, 0x2f, 0xad, 0x6d, 0x45, 0xef, 0x0, 0x35, 0xad, 0x30, 0xf, 0x3b, 0xda, 0x5c, 0xe2, 0xe6, 0x9f, 0xa9, 0xce, 0xc6, 0x52, 0xc8, 0xf7, 0x56, 0x8b, 0xe1, 0xe1, 0x97, 0x39, 0x66, 0x80, 0x2f, 0x3d, 0x57, 0x2e, 0x6b, 0x89, 0x2d, 0x15, 0x8f, 0x3d, 0x67, 0xe5, 0x51, 0xac, 0x6c, 0xd1, 0x9f, 0xb6, 0xb1, 0x17, 0x84, 0xdb, 0x6c, 0xa0, 0xb2, 0xf4, 0x35, 0x83, 0x36, 0xe6, 0x77, 0x1f, 0x1, 0x67, 0xde, 0x74, 0x37, 0xb9, 0xba, 0x36, 0x40, 0xe5, 0x49, 0x13, 0x4e, 0x33, 0x1a, 0x8c, 0xb2, 0x1, 0x80, 0x8, 0xc0, 0xbc, 0x72, 0xfb, 0x3e, 0x6f, 0x6d, 0x42, 0xa8, 0xe6, 0x64, 0x69, 0xce, 0xbf, 0x15, 0xed, 0xd4, 0x92, 0x89, 0x2d, 0xc0, 0x6e, 0x1b, 0xb, 0x6e, 0x1d, 0xf5, 0xf9, 0x6, 0x9b, 0x8, 0xf2, 0xbf, 0x87, 0xb9, 0xf9, 0xe9, 0xb4, 0x68, 0x55, 0xda, 0x92, 0x24, 0xcc, 0xe5, 0x61, 0x91, 0xee, 0xc6, 0x9e, 0xfc, 0x72, 0x99, 0x72, 0x9, 0x32, 0xf4, 0x3a, 0x63, 0x3d, 0x85, 0xcd, 0x5c, 0x70, 0x57, 0x86, 0x2, 0x4d, 0xa6, 0xf8, 0x63, 0x84, 0xbb, 0x0, 0xc3, 0xe9, 0x7d, 0xda, 0x28, 0xe5, 0xd5, 0x1b, 0x13, 0xf2, 0x96, 0xea, 0x8, 0x91, 0xda, 0x6b, 0xd7, 0x3, 0x40, 0xce, 0x2a, 0x88, 0xfc, 0x9b, 0x9b, 0xf3, 0x2e, 0xfa, 0xab, 0x74, 0x6e, 0x38, 0x55, 0x18, 0x78, 0x9f, 0xf8, 0xa6, 0x64, 0xd2, 0x6d, 0x2, 0x3, 0x1, 0x0, 0x1, 0xa3, 0x82, 0x1, 0x91, 0x30, 0x82, 0x1, 0x8d, 0x30, 0x12, 0x6, 0x3, 0x55, 0x1d, 0x13, 0x1, 0x1, 0xff, 0x4, 0x8, 0x30, 0x6, 0x1, 0x1, 0xff, 0x2, 0x1, 0x1, 0x30, 0x81, 0xe4, 0x6, 0x3, 0x55, 0x1d, 0x20, 0x4, 0x81, 0xdc, 0x30, 0x81, 0xd9, 0x30, 0x81, 0xd6, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x2f, 0x1, 0x2, 0x1, 0x30, 0x81, 0xc8, 0x30, 0x36, 0x6, 0x8, 0x2b, 0x6, 0x1, 0x5, 0x5, 0x7, 0x2, 0x1, 0x16, 0x2a, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x61, 0x64, 0x6f, 0x62, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6d, 0x69, 0x73, 0x63, 0x2f, 0x70, 0x6b, 0x69, 0x2f, 0x63, 0x64, 0x73, 0x5f, 0x63, 0x70, 0x2e, 0x68, 0x74, 0x6d, 0x6c, 0x30, 0x81, 0x8d, 0x6, 0x8, 0x2b, 0x6, 0x1, 0x5, 0x5, 0x7, 0x2, 0x2, 0x30, 0x81, 0x80, 0x1a, 0x7e, 0x54, 0x68, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x69, 0x73, 0x73, 0x75, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x63, 0x6f, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x20, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x61, 0x74, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x61, 0x64, 0x6f, 0x62, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6d, 0x69, 0x73, 0x63, 0x2f, 0x70, 0x6b, 0x69, 0x2f, 0x63, 0x64, 0x73, 0x5f, 0x63, 0x70, 0x2e, 0x68, 0x74, 0x6d, 0x6c, 0x30, 0x2d, 0x6, 0x3, 0x55, 0x1d, 0x1f, 0x4, 0x26, 0x30, 0x24, 0x30, 0x22, 0xa0, 0x20, 0xa0, 0x1e, 0x86, 0x1c, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x72, 0x6c, 0x2e, 0x61, 0x64, 0x6f, 0x62, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x64, 0x73, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x14, 0x6, 0x3, 0x55, 0x1d, 0x25, 0x4, 0xd, 0x30, 0xb, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x2f, 0x1, 0x1, 0x5, 0x30, 0xb, 0x6, 0x3, 0x55, 0x1d, 0xf, 0x4, 0x4, 0x3, 0x2, 0x1, 0x6, 0x30, 0x1d, 0x6, 0x3, 0x55, 0x1d, 0xe, 0x4, 0x16, 0x4, 0x14, 0x59, 0xd8, 0x24, 0xc2, 0xcf, 0x6b, 0x6, 0x42, 0xd4, 0x95, 0x76, 0xb5, 0x29, 0x5c, 0xf5, 0xd8, 0x41, 0x2b, 0x24, 0x5f, 0x30, 0x1f, 0x6, 0x3, 0x55, 0x1d, 0x23, 0x4, 0x18, 0x30, 0x16, 0x80, 0x14, 0x82, 0xb7, 0x38, 0x4a, 0x93, 0xaa, 0x9b, 0x10, 0xef, 0x80, 0xbb, 0xd9, 0x54, 0xe2, 0xf1, 0xf, 0xfb, 0x80, 0x9c, 0xde, 0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0xb, 0x5, 0x0, 0x3, 0x82, 0x1, 0x1, 0x0, 0x3, 0x80, 0xd0, 0xb, 0x7e, 0x3e, 0x47, 0x44, 0x8a, 0xc5, 0x38, 0xc5, 0x7e, 0x36, 0x5e, 0xcd, 0x60, 0x82, 0x65, 0x62, 0xf3, 0x86, 0xcc, 0x23, 0xbe, 0x47, 0xd7, 0x75, 0x4, 0xc9, 0xdc, 0x5b, 0x3f, 0x12, 0xd3, 0xdb, 0x26, 0x75, 0x59, 0x1d, 0xb6, 0xd4, 0xa, 0x58, 0x3f, 0x5a, 0xd7, 0x28, 0x14, 0xbf, 0x56, 0x86, 0xbd, 0xba, 0xc2, 0x64, 0x20, 0xc8, 0x6e, 0x7d, 0xa9, 0xe8, 0xde, 0xbd, 0x9f, 0x6, 0xff, 0x18, 0xea, 0x57, 0xa1, 0xd7, 0x80, 0x29, 0x87, 0xe8, 0xd0, 0x7b, 0x57, 0x80, 0x45, 0x68, 0x4f, 0x9, 0xa4, 0x83, 0x4c, 0x2d, 0x73, 0x2a, 0x60, 0xee, 0x55, 0x21, 0x9, 0x2c, 0x95, 0x3f, 0xc3, 0x71, 0xe1, 0xb8, 0xad, 0x9c, 0xab, 0x94, 0x37, 0xec, 0x71, 0x4e, 0x66, 0x4d, 0xe8, 0x20, 0x49, 0x4a, 0xea, 0xc7, 0xd7, 0x3c, 0x96, 0xeb, 0xf, 0xc5, 0xf9, 0xd4, 0x7d, 0x5c, 0x13, 0x81, 0x3a, 0xdf, 0xc3, 0x18, 0xc0, 0x47, 0xae, 0x84, 0xff, 0x12, 0xfd, 0xb8, 0x4, 0xc9, 0x9a, 0x5b, 0x33, 0x83, 0x6e, 0xec, 0x11, 0x2c, 0x35, 0x3, 0x71, 0xac, 0xa5, 0xd1, 0xd3, 0x52, 0xd9, 0x9a, 0x70, 0xcf, 0xfe, 0x9d, 0xc0, 0x7e, 0x3, 0x2d, 0x86, 0xe7, 0x7d, 0x66, 0x10, 0x2c, 0x45, 0x86, 0x37, 0x88, 0x9c, 0xe3, 0xb5, 0x39, 0x9f, 0x1c, 0xb2, 0x67, 0x96, 0x43, 0x3a, 0xc2, 0x2c, 0xcd, 0xfa, 0x3d, 0x9a, 0x4, 0x32, 0x5c, 0xb1, 0x3d, 0xf3, 0x2, 0xb4, 0x31, 0x1, 0x4a, 0xdf, 0x92, 0x5b, 0x7d, 0x5f, 0xb6, 0xd0, 0x7, 0xc, 0x93, 0xae, 0xe5, 0xa9, 0xe2, 0x19, 0xdb, 0xc, 0xa3, 0xf3, 0xc8, 0xb1, 0x14, 0xd, 0x61, 0xb9, 0x3, 0x9e, 0xd3, 0xf4, 0x7, 0x17, 0x2b, 0xd9, 0x4c, 0x70, 0x5e, 0x48, 0x6f, 0xc2, 0xc5, 0x3a, 0x9, 0xb0, 0xed, 0x27, 0x5a, 0x11, 0xcb, 0x31, 0x82, 0x2, 0xc6, 0x30, 0x82, 0x2, 0xc2, 0x2, 0x1, 0x1, 0x30, 0x81, 0x88, 0x30, 0x72, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d, 0x73, 0x61, 0x31, 0x17, 0x30, 0x15, 0x6, 0x3, 0x55, 0x4, 0xb, 0x13, 0xe, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x43, 0x44, 0x53, 0x31, 0x2f, 0x30, 0x2d, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x26, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x20, 0x43, 0x41, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x2, 0x12, 0x11, 0x21, 0xd2, 0xd1, 0x82, 0xa, 0xf0, 0xa5, 0xc5, 0x48, 0x14, 0x9a, 0x32, 0x74, 0xdc, 0xc3, 0x43, 0x57, 0x30, 0xd, 0x6, 0x9, 0x60, 0x86, 0x48, 0x1, 0x65, 0x3, 0x4, 0x2, 0x1, 0x5, 0x0, 0xa0, 0x82, 0x1, 0xe, 0x30, 0x1a, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x9, 0x3, 0x31, 0xd, 0x6, 0xb, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x9, 0x10, 0x1, 0x4, 0x30, 0x2f, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x9, 0x4, 0x31, 0x22, 0x4, 0x20, 0x98, 0x7a, 0x55, 0x9c, 0x19, 0x83, 0x73, 0xd0, 0xcb, 0xfc, 0xe1, 0x4, 0x40, 0xf, 0x78, 0x77, 0xe, 0xbe, 0x86, 0xe5, 0xe0, 0x67, 0xa, 0x2b, 0xc8, 0x3c, 0x68, 0x75, 0xef, 0x7, 0x6d, 0x99, 0x30, 0x81, 0xbe, 0x6, 0xb, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x9, 0x10, 0x2, 0xc, 0x31, 0x81, 0xae, 0x30, 0x81, 0xab, 0x30, 0x81, 0xa8, 0x30, 0x81, 0xa5, 0x4, 0x14, 0xba, 0x64, 0xa3, 0x69, 0x93, 0xb8, 0xb6, 0x4, 0xf7, 0xfe, 0x65, 0xd3, 0x7d, 0x8f, 0x8e, 0x68, 0x96, 0xfc, 0x96, 0xb, 0x30, 0x81, 0x8c, 0x30, 0x76, 0xa4, 0x74, 0x30, 0x72, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d, 0x73, 0x61, 0x31, 0x17, 0x30, 0x15, 0x6, 0x3, 0x55, 0x4, 0xb, 0x13, 0xe, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x43, 0x44, 0x53, 0x31, 0x2f, 0x30, 0x2d, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x26, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x20, 0x43, 0x41, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x2, 0x12, 0x11, 0x21, 0xd2, 0xd1, 0x82, 0xa, 0xf0, 0xa5, 0xc5, 0x48, 0x14, 0x9a, 0x32, 0x74, 0xdc, 0xc3, 0x43, 0x57, 0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0x1, 0x5, 0x0, 0x4, 0x82, 0x1, 0x0, 0x92, 0x89, 0xaa, 0x92, 0xf0, 0x29, 0x62, 0x1c, 0xef, 0x19, 0x23, 0xb9, 0x46, 0xc4, 0x7d, 0xe1, 0x89, 0x4e, 0xa3, 0x72, 0xa9, 0xe1, 0xf6, 0xc9, 0x54, 0x8b, 0xc5, 0xab, 0x5a, 0xbb, 0x2c, 0xe, 0x41, 0x63, 0x3, 0x8f, 0xc3, 0xae, 0xf4, 0x46, 0x83, 0x72, 0x96, 0xa0, 0xba, 0xf0, 0xbf, 0x2f, 0xed, 0x47, 0xad, 0xd7, 0x14, 0x6f, 0x57, 0x7d, 0xd3, 0x12, 0xd1, 0xe7, 0x9b, 0xac, 0x48, 0x72, 0xc4, 0x55, 0x3f, 0x55, 0xda, 0xe, 0x91, 0x1d, 0x5b, 0xb3, 0x14, 0x30, 0x2c, 0x29, 0xd3, 0x41, 0x72, 0x17, 0x5e, 0x37, 0x1b, 0xec, 0xfe, 0x6b, 0x4a, 0x98, 0x6b, 0x63, 0x7d, 0x1a, 0x7f, 0x3b, 0x84, 0xc1, 0x55, 0x50, 0x26, 0xa7, 0x1e, 0x5d, 0x9b, 0xea, 0x17, 0x5b, 0xfd, 0x35, 0x41, 0xa1, 0x6a, 0x35, 0xc6, 0xdd, 0x11, 0xc5, 0x4e, 0xae, 0x3c, 0x85, 0x5d, 0x10, 0xb8, 0xe8, 0x8d, 0xf, 0x3d, 0x3c, 0xe8, 0xef, 0x2c, 0xff, 0xac, 0x44, 0x38, 0x85, 0xcc, 0xee, 0xb6, 0xe8, 0xf7, 0xae, 0xaa, 0x97, 0xbd, 0x68, 0x4a, 0xbe, 0x3e, 0xcf, 0xe, 0x71, 0xcd, 0xf3, 0x3e, 0xef, 0xea, 0x20, 0xd5, 0x3c, 0x40, 0xcd, 0x5a, 0x88, 0x7c, 0x16, 0xd4, 0xd8, 0x8, 0xf4, 0x35, 0x6b, 0xca, 0xa8, 0xce, 0x2d, 0x53, 0x99, 0x87, 0xa3, 0x31, 0xd, 0x16, 0xa5, 0x43, 0x1c, 0xff, 0x17, 0x82, 0xd4, 0x39, 0x7, 0xd6, 0xa6, 0xad, 0x2b, 0x1a, 0x48, 0x32, 0x70, 0x5d, 0x8e, 0xfe, 0xe7, 0x54, 0x8b, 0x15, 0xa5, 0x76, 0x2e, 0xa0, 0x2a, 0x9c, 0x4, 0x2e, 0x3e, 0x0, 0x9f, 0xbc, 0x7d, 0xce, 0x71, 0x94, 0x52, 0x5c, 0x6d, 0x78, 0xc5, 0xd2, 0xbc, 0x2e, 0x78, 0x29, 0xb5, 0x95, 0x2a, 0x34, 0x9a, 0x55, 0x60, 0x9a, 0x18, 0x1b, 0xc1, 0x4d, 0x47, 0xc1, 0xa1, 0xe9, 0x16, 0x3b, 0xee, 0x6b, 0xd2}

	timeServerSignedResponse, err := timestamp.ParseResponse(tspResponse)
	if err != nil {
		calculatedEndTime.Errors = append(calculatedEndTime.Errors, fmt.Sprintf("TSP: %s", err))
	} else {
		calculatedEndTime.TimeServerCurrentTime = timeServerSignedResponse.Time
	}

	//from time chaincode
	timeChaincodeResponse := APIstub.InvokeChaincode("time-app", ToChaincodeArgs("GetCurrentTime"), "mychannel")
	if timeChaincodeResponse.Status != shim.OK {
		errStr := fmt.Sprintf("Failed to query chaincode. Got error: %s", timeChaincodeResponse.Payload)
		calculatedEndTime.Errors = append(calculatedEndTime.Errors, fmt.Sprintf("CHAINCODE: %s", errStr))
		// return shim.Error(errStr)
	} else {
		chaincodeCurrentTime := HyperledgerFabricTimestamp{}
		err = json.Unmarshal(timeChaincodeResponse.Payload, &chaincodeCurrentTime)
		if err == nil {
			calculatedEndTime.ChaincodeCurrentTime = chaincodeCurrentTime.CurrentTime
		}
	}

	parkingTime.CurrentTimestamps = calculatedEndTime
	//END

	parkingTime.ParkingEnd = calculatedEndTime.TransactionTime

	delta := parkingTime.ParkingEnd.Sub(parkingTime.ParkingStart)
	totalCost := int(delta.Minutes()) * parkingTime.CostPerMinute
	parkingTime.Cost = totalCost

	s.ParkingTimeService.Save(APIstub, parkingTime)
	fmt.Printf("Saved parking type: %s\n", parkingTime)

	owner, err := s.UserService.Get(APIstub, parkingTime.Parkingspot.Owner.Id)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to change parkingspot owner balance: %s", err))
	}

	renter, err := s.UserService.Get(APIstub, parkingTime.Renter.Id)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to change renter balance: %s", err))
	}

	owner.Balance.AddCents(totalCost)
	renter.Balance.SubtractCents(totalCost)

	owner, err = s.UserService.Save(APIstub, owner)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to add parkingspot owner balance: %s", err))
	}
	renter, err = s.UserService.Save(APIstub, renter)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to reduce renter balance: %s", err))
	}

	resultAsBytes, _ := json.Marshal(parkingTime)
	return shim.Success(resultAsBytes)
}

func (s *SmartContract) FindParkingspotToRent(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1, FindParkingspot parameter")
	}

	findParkingspotParameter := FindParkingspotParameter{}
	err := json.Unmarshal([]byte(args[0]), &findParkingspotParameter)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal FindParkingspotParameter parameter: %s", err))
	}

	var resultsIterator shim.StateQueryIteratorInterface
	if findParkingspotParameter.Zoom != 0 {
		location := s.GeoHashService.CreateLocationUsingZoom(findParkingspotParameter.Location.X, findParkingspotParameter.Location.Y, findParkingspotParameter.Zoom)
		resultsIterator, err = s.findParkingspotForLocationAndTime(APIstub, location, findParkingspotParameter.ParkingStart, findParkingspotParameter.ParkingEnd)

	} else {
		resultsIterator, err = s.findParkingspotOverlaping(APIstub, findParkingspotParameter.ParkingStart, findParkingspotParameter.ParkingEnd)
	}

	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	result, err := s.marshalQueryResult(resultsIterator)
	fmt.Printf("- FindParkingspotToRent:\n%s\n", result)

	return shim.Success([]byte(result))

}

func (s *SmartContract) GetOwnerParkingspots(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1, GetOwnerParkingspots parameter")
	}

	OwnerId := args[0]

	queryString := fmt.Sprintf("{\"selector\": {\"owner.id\": {\"$eq\": \"%s\"}}}", OwnerId)
	resultsIterator, err := APIstub.GetQueryResult(queryString)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to query: %s", err))
	}
	defer resultsIterator.Close()

	result, err := s.marshalQueryResult(resultsIterator)
	return shim.Success([]byte(result))
}

func (s *SmartContract) GetParkingspot(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1, FindParkingspot parameter")
	}

	id := args[0]
	compositeKey, _ := APIstub.CreateCompositeKey("Parkingspot", []string{id})

	resultAsBytes, err := APIstub.GetState(compositeKey)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to get Parkingspot(%s): %s", id, err))
	}

	return shim.Success(resultAsBytes)
}


func (s *SmartContract) SaveParkingspot(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2, id and Parkingspot")
	}
	parkingspot := Parkingspot{}
	err := json.Unmarshal([]byte(args[1]), &parkingspot)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parameter: %s", err))
	}

	parkingspot.Id = args[0]
	parkingspot.Location = s.GeoHashService.CreateLocation(parkingspot.Location.X, parkingspot.Location.Y)

	compositeKey, _ := APIstub.CreateCompositeKey("Parkingspot", []string{parkingspot.Id})
	resultAsBytes, err := json.Marshal(parkingspot)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to marshal parameter: %s", err))
	}

	// Add Object JSON to state
	err = APIstub.PutState(compositeKey, resultAsBytes)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to save parkingspot: %s", err))
	}

	return shim.Success(resultAsBytes)
}

func (s *SmartContract) GetUsers(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 0 {
		return shim.Error("Incorrect number of arguments. Expecting 0")
	}

	// findParkingspotParameter := FindParkingspotParameter{}
	// err := json.Unmarshal([]byte(args[0]), &findParkingspotParameter)
	// if err != nil {
	// 	return shim.Error(fmt.Sprintf("Failed to unmarshal parameter: %s", err))
	// }
	//
	// queryString := fmt.Sprintf("{\"selector\": {\"name\": {\"$regex\": \"%s\"}}}", findParkingspotParameter.Name)
	// resultsIterator, err := APIstub.GetQueryResult(queryString)

	// compositeKeyStart, _ := APIstub.CreateCompositeKey("User", []string{0})
	// compositeKeyEnd, _ := APIstub.CreateCompositeKey("User", []string{9999})
	resultsIterator, err := APIstub.GetStateByPartialCompositeKey("User", []string{})

	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to query all users: %s", err))
	}
	defer resultsIterator.Close()

	result, err := s.marshalQueryResult(resultsIterator)
	return shim.Success([]byte(result))
}

func (s *SmartContract) GetUser(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1, User id")
	}

	id := args[0]
	compositeKey, _ := APIstub.CreateCompositeKey("User", []string{id})

	resultAsBytes, err := APIstub.GetState(compositeKey)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to get user(%s): %s", id, err))
	}

	return shim.Success(resultAsBytes)
}

func (s *SmartContract) SetUser(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2, id and User")
	}
	user := User{}
	err := json.Unmarshal([]byte(args[1]), &user)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parameter: %s", err))
	}

	user.Id = args[0]

	compositeKey, _ := APIstub.CreateCompositeKey("User", []string{user.Id})
	resultAsBytes, err := json.Marshal(user)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to marshal parameter: %s", err))
	}

	// Add Object JSON to state
	err = APIstub.PutState(compositeKey, resultAsBytes)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to save user: %s", err))
	}

	return shim.Success(resultAsBytes)
}

func (s *SmartContract) get(APIstub shim.ChaincodeStubInterface, id string) (ParkingTime, error) {
	resultAsBytes, err := APIstub.GetState(id)
	parkingTime := ParkingTime{}
	if err != nil {
		return parkingTime, err
	}
	if resultAsBytes == nil {
		return parkingTime, nil
	}
	err = json.Unmarshal(resultAsBytes, &parkingTime)
	if err != nil {
		return parkingTime, err
	}

	return parkingTime, nil
}

func (s *SmartContract) put(APIstub shim.ChaincodeStubInterface, id string, parkingTime ParkingTime) ([]byte, error) {
	resultAsBytes, err := json.Marshal(parkingTime)
	if err != nil {
		return resultAsBytes, err
	}
	err = APIstub.PutState(id, resultAsBytes)
	return resultAsBytes, err
}

func (s *SmartContract) findParkingspotOverlaping(APIstub shim.ChaincodeStubInterface, ParkingStart time.Time, ParkingEnd time.Time) (shim.StateQueryIteratorInterface, error) {
	ParkingStartIso,_ := ParkingStart.MarshalText()
	ParkingEndIso,_ := ParkingEnd.MarshalText()
	fmt.Printf("findParkingspotOverlaping: %s, %s\n", ParkingStartIso, ParkingEndIso)
	return s.findParkingspotOverlapingIsoString(APIstub, string(ParkingStartIso), string(ParkingEndIso));
}

func (s *SmartContract) findParkingspotForLocationAndTime(APIstub shim.ChaincodeStubInterface, location ParkingSpotLocation, ParkingStart time.Time, ParkingEnd time.Time) (shim.StateQueryIteratorInterface, error) {
	LocationGeoHash := location.GeoHash
	ParkingStartIso,_ := ParkingStart.MarshalText()
	ParkingEndIso,_ := ParkingEnd.MarshalText()
	fmt.Printf("findParkingspotForLocationAndTime: %s, %s, %s\n", LocationGeoHash, ParkingStartIso, ParkingEndIso)
	return s.findParkingspotForLocationAndTimeIsoString(APIstub, LocationGeoHash, string(ParkingStartIso), string(ParkingEndIso));
}

func (s *SmartContract) findParkingspotOverlapingIsoString(APIstub shim.ChaincodeStubInterface, ParkingStart string, ParkingEnd string) (shim.StateQueryIteratorInterface, error) {
	// fmt.Printf("findParkingspotOverlapingIsoString: %s, %s\n", ParkingFindParkingspotStart, ParkingEnd)
	queryString := "{" +
		"\"selector\": {" +
			"\"$or\": [" +
				"{" +
					"\"parkingStart\": {\"$lte\": \"" + ParkingStart + "\"}," +
					"\"parkingEnd\": {\"$gte\": \"" + ParkingEnd + "\"}," +
					"\"parkingType\": {\"$eq\": \"FREE\"}" +
				"}, {" +
					"\"$and\": [" +
						"{" +
							"\"$or\": [" +
								"{" +
									"\"parkingStart\": {\"$lt\": \"" + ParkingStart + "\"}" +
								"}, {" +
									"\"parkingStart\": {\"$lt\": \"" + ParkingEnd + "\"}" +
								"}" +
							"]" +
						"}, {" +
							"\"$or\": [" +
								"{" +
									"\"parkingEnd\": {\"$gt\": \"" + ParkingStart + "\"}" +
								"}, " +
								"{" +
									"\"parkingEnd\": {\"$gt\": \"" + ParkingEnd + "\"}" +
								"}" +
							"]" +
						"}" +
					"]," +
					"\"parkingType\": {\"$ne\": \"FREE\"}" +
				"}" +
			"]" +
		"}" +
	"}"
	fmt.Printf("findParkingspotOverlapingIsoString query: %s\n", queryString)
	resultsIterator, err := APIstub.GetQueryResult(queryString)
	if err != nil {
		return resultsIterator, err
	}
	defer resultsIterator.Close()

	return resultsIterator, nil
}

func (s *SmartContract) findParkingspotForLocationAndTimeIsoString(APIstub shim.ChaincodeStubInterface, LocationGeoHash string, ParkingStart string, ParkingEnd string) (shim.StateQueryIteratorInterface, error) {
	queryString := "{" +
		"\"selector\": {" +
			"\"$or\": [" +
				"{" +
					"\"parkingStart\": {\"$lte\": \"" + ParkingStart + "\"}," +
					"\"parkingEnd\": {\"$gte\": \"" + ParkingEnd + "\"}," +
					"\"parkingspot.location.geoHash\": {\"$regex\": \"" + LocationGeoHash + ".*\"}," +
					"\"parkingType\": {\"$eq\": \"FREE\"}" +
				"}, {" +
					"\"$and\": [" +
						"{" +
							"\"$or\": [" +
								"{" +
									"\"parkingStart\": {\"$lt\": \"" + ParkingStart + "\"}" +
								"}, {" +
									"\"parkingStart\": {\"$lt\": \"" + ParkingEnd + "\"}" +
								"}, {" +
									"\"parkingspot.location.geoHash\": {\"$regex\": \"" + LocationGeoHash + ".*\"}" +
								"}" +
							"]" +
						"}, {" +
							"\"$or\": [" +
								"{" +
									"\"parkingEnd\": {\"$gt\": \"" + ParkingStart + "\"}" +
								"}, " +
								"{" +
									"\"parkingEnd\": {\"$gt\": \"" + ParkingEnd + "\"}" +
								"}, {" +
									"\"parkingspot.location.geoHash\": {\"$regex\": \"" + LocationGeoHash + ".*\"}" +
								"}" +
							"]" +
						"}" +
					"]," +
					"\"parkingType\": {\"$ne\": \"FREE\"}" +
				"}" +
			"]" +
		"}" +
	"}"
	fmt.Printf("findParkingspotOverlapingIsoString query: %s\n", queryString)
	resultsIterator, err := APIstub.GetQueryResult(queryString)
	if err != nil {
		return resultsIterator, err
	}
	defer resultsIterator.Close()

	return resultsIterator, nil
}

func (s *SmartContract) unmarshal(jsonStringBody string) (ParkingTime, error) {
	parkingTime := ParkingTime{}
	err := json.Unmarshal([]byte(jsonStringBody), &parkingTime)
	return parkingTime, err
}

func (s *SmartContract) marshalQueryResult(resultsIterator shim.StateQueryIteratorInterface) (string, error) {
	// buffer is a JSON array containing QueryResults
	var buffer bytes.Buffer
	buffer.WriteString("[")

	bArrayMemberAlreadyWritten := false
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return "", err
		}
		// Add comma before array members,suppress it for the first array member
		if bArrayMemberAlreadyWritten == true {
			buffer.WriteString(",")
		}
		// buffer.WriteString("{")
		// buffer.WriteString("\"Key\":")
		// buffer.WriteString("\"")
		// buffer.WriteString(queryResponse.Key)
		// buffer.WriteString("\"")
    // 
		// buffer.WriteString(", \"Record\":")
		//// Record is a JSON object, so we write as-is
		buffer.WriteString(string(queryResponse.Value))
		// buffer.WriteString("}")
		bArrayMemberAlreadyWritten = true
	}
	buffer.WriteString("]")
	return buffer.String(), nil
}

/*
 * main function *
calls the Start function
The main function starts the chaincode in the container during instantiation.
*/
func main() {

	// Create a new Smart Contract
	err := shim.Start(&SmartContract{
		ParkingspotService:   parkingservice.GetParkingspotService(),
		ParkingTimeService:   parkingservice.GetParkingTimeService(),
		UserService:          parkingservice.GetUserService(),
		ParkingCommonService: parkingservice.GetParkingCommonService(),
		GeoHashService: parkingservice.GetGeoHashService(),
	})
	if err != nil {
		fmt.Printf("Error creating new Smart Contract: %s", err)
	} else {
		fmt.Println("SVENZIK SampleChaincode successfully started")
	}
}

func ToChaincodeArgs(args ...string) [][]byte {
	bargs := make([][]byte, len(args))
	for i, arg := range args {
		bargs[i] = []byte(arg)
	}
	return bargs
}
